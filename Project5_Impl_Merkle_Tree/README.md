# Impl Merkle Tree following RFC6962

## merkle tree基础知识
`Merkle Tree`可以看做`Hash List`的泛化（`Hash List`可以看作一种特殊的`Merkle Tree`，即树高为2的多叉`Merkle Tree`）。

在最底层，和哈希列表一样，我们把数据分成小的数据块，有相应地哈希和它对应。但是往上走，并不是直接去运算根哈希，而是把相邻的两个哈希合并成一个字符串，然后运算这个字符串的哈希，这样每两个哈希就结婚生子，得到了一个”子哈希“。

如果最底层的哈希总数是单数，那到最后必然出现一个单身哈希，这种情况就直接对它进行哈希运算，所以也能得到它的子哈希。于是往上推，依然是一样的方式，可以得到数目更少的新一级哈希，最终必然形成一棵倒挂的树，到了树根的这个位置，这一代就剩下一个根哈希了，我们把它叫做 `Merkle Root`。

![1](./image/tree.png)

`merkle tree`具有以下作用：
* 完整性验证：
  Merkle树可以验证数据是否被篡改。通过将数据分割成固定大小的块，并对每个块进行哈希计算，构建Merkle树。根节点的哈希值可以用于验证整个数据集是否完整，即使只有部分数据块可用。
* 高效验证：
  Merkle树允许快速验证特定数据块的完整性，而无需验证整个数据集。这对于大型数据集和分布式存储系统尤为有用。

## 代码实现细节
1、采用的哈希方法：sha256

2、叶子节点数据块大小：32字节（为了与其他节点的大小统一）
  
3、merkle tree采用二维数组方式存储，访问速度更快

## 结果展示
我们构建一个merkle tree，并用verify函数对数据进行完整性检验：
```
data=generate_random_string(10000)
Merkle_tree,root_value=cons_merkle(data)
verify(data,root_value)
```
结果如下：

![2](./image/result.png)
